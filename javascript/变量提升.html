<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>

    // let a=1;
    // function fn(){
    //     console.log(a);
    //     let a=2;
    // }
    // fn();


    //var 可以重复声明
    // var a=1;
    // var a=2;
    // console.log(a);
    //

    //let 不可以重复声明
    // let a=1;
    // let a=2;
    // console.log(a);


    //js中只有全局作用域，函数作用域，没有块级作用域
    //let没有变量提升与暂时性死区,在
    // console.log(a);  //报错： Uncaught ReferenceError, 如果使用var声明，就会打印undefind
    // let a=1;

    //es6中可以使用let 定义快级作用域变量
    // {
    //     var a=1;
    // }
    // console.log(a); //能打印出a=1;   var没有块级作用域



    //es6中的let 可以声明块级作用域的变量
    // {
    //     let a=1;
    // }
    // console.log(a); //a is not define

    //let配合for循环的独特应用
    // for (var i=0;i<10;i++){
    //     setTimeout(function (){  //同步注册回调函数到异步的宏任务队列
    //        console.log(i);     //执行此代码时，同步代码for循环已经执行完成
    //     },0)
    // }
    //输出10个0
    //原因：js事件循环机制，setTimeout机制


    //i 虽然在全局作用域声明，但是for循环局部作用域中使用的时候，变量会被固定，不受外界干扰
    // for (let i=0;i<10;i++){
    //     setTimeout(function (){
    //         console.log(i);    //i是循环体内局部作用域，不受外界影响
    //     },0)
    // }
    //输出结果：0,1,2,3...,10


    //var 存在变量提升，局部变量，和全局变量
    // var a=1;
    // function fn(){
    //     a=3;
    //     console.log(a);
    //     var a=2;
    // }
    // fn()   //3
    //
    //
    // let a=1;
    // function fn(){
    //     a=3;
    //     console.log(a);
    //     var a=2;
    // }
    // fn()   //3


    //var 产生的问题，内层变量可能会覆盖外层变量
    // var a=1;
    // function fn(){
    //     console.log(a);
    //     var a=2;
    // }
    // fn();  //undefined  变量提升



    // let a=1;
    // function fn(){
    //     //存在暂时性死区，无法访问
    //     console.log(a);
    //     let a=2;
    // }
    // fn();  //初始化前不能调用




</script>
</body>
</html>
